#include <bits/stdc++.h>


/* Templates
Templates are parameterized by one or more template parameters, of three kinds: type template parameters, non-type template parameters, and template template parameters.

When template arguments are provided, or, for function and class(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a specialization of the template, that is, a specific type or a specific function lvalue. Specializations may also be provided explicitly: full specializations are allowed for class, variable(since C++14) and function templates, partial specializations are only allowed for class templates and variable templates(since C++14).

When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is instantiated (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template does not instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

cppreference: https://en.cppreference.com/w/cpp/language/templates
*/

/* Partial template specialization
Allows customizing class and variable(since C++14) templates for a given category of template arguments.

cppreference: https://en.cppreference.com/w/cpp/language/template_specialization
*/
template <typename L, typename R>
decltype(auto) max(L l, R r)
{
    return (l > r) ? l : r;
}

template <typename T>
bool IsValid(T collection[], int threshold, size_t size)
{
    T sum{};
    for (size_t i{0}; i < size; ++i)
        sum += collection[i];

    return (sum > threshold) ? true : false;
}

/*
auto add(auto a, auto b)
{
    return a + b;
}
*/

template <typename T>
T add(T a, T b)
{
    return a + b;
}

/* Explicit (full) template specialization
Allows customizing the template code for a given set of template arguments.

cppreference: https://en.cppreference.com/w/cpp/language/template_specialization
*/
template <typename T>
bool IsInt(T n)
{
    static_assert(std::is_integral_v<T>, "input is not integer");
    return true;
}

int main()
{
    int a = 30;
    double b = 20.8;
    std::cout << "Bigger one ? " << max(a, b) << std::endl;

    double temps[]{33.3, 28.2, 15.8, 0.3, -3, -15, 40.8, 29.6, 11.3, 13.9};
    auto result = IsValid(temps, 100, std::size(temps));

    std::cout << std::boolalpha;
    std::cout << "High temperature: " << result << std::endl;

    auto sub = []<typename L, typename R>(L l, R r)
    { return l - r; };

    std::cout << "Is integer? " << IsInt(a) << std::endl;
    // std::cout << "Is integer? " << IsInt(b) << std::endl;   // assertion failed

    return 0;
}